<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/dendron-main/favicon.ico"/><title>Tutorial</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal Knowledge Space"/><meta property="og:title" content="Tutorial"/><meta property="og:description" content="Personal Knowledge Space"/><meta property="og:url" content="https://sid1081.github.io/dendron-main/notes/rikfe3qd9gvj5o6a6l92cx8/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="3/25/2025"/><meta property="article:modified_time" content="4/10/2025"/><link rel="canonical" href="https://sid1081.github.io/dendron-main/notes/rikfe3qd9gvj5o6a6l92cx8/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/dendron-main/_next/static/css/c3b5c8984096a078.css" as="style"/><link rel="stylesheet" href="/dendron-main/_next/static/css/c3b5c8984096a078.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/dendron-main/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/dendron-main/_next/static/chunks/webpack-0caed3b86e25c9d3.js" defer=""></script><script src="/dendron-main/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/dendron-main/_next/static/chunks/main-af01d34aaf1cbbc0.js" defer=""></script><script src="/dendron-main/_next/static/chunks/pages/_app-f3ffa24acc1f5021.js" defer=""></script><script src="/dendron-main/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/dendron-main/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/dendron-main/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/dendron-main/_next/static/j1tAvk9N20cOpobDNsQ-j/_buildManifest.js" defer=""></script><script src="/dendron-main/_next/static/j1tAvk9N20cOpobDNsQ-j/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="tutorial"><a aria-hidden="true" class="anchor-heading icon-link" href="#tutorial"></a>Tutorial</h1>
<h3 id="intro"><a aria-hidden="true" class="anchor-heading icon-link" href="#intro"></a>Intro</h3>
<ul>
<li>
<p>The DOM is an object representation of the HTML elements. It acts as a bridge between your code and the user interface, and has a tree-like structure with parent and child relationships.</p>
</li>
<li>
<p>You can use DOM methods and JavaScript, to listen to user events and manipulate the DOM by selecting, adding, updating, and deleting specific elements in the user interface. DOM manipulation allows you to not only target specific elements, but also change their style and content.</p>
</li>
<li>
<p>Updating the DOM with plain JavaScript is very powerful but verbose. You've written all this code to add an <code>&#x3C;h1></code> element with some text:</p>
</li>
<li>
<p>As the size of an app or team grows, it can become increasingly challenging to build applications this way - writing code that manuipulates the DOM to perform business logic.</p>
</li>
<li>
<p>With this approach, developers spend a lot of time writing instructions to tell the computer how it should do things. But wouldn't it be nice to describe what you want to show and let the computer figure out how to update the DOM?</p>
</li>
</ul>
<h3 id="trees-in-react"><a aria-hidden="true" class="anchor-heading icon-link" href="#trees-in-react"></a>Trees in React</h3>
<ul>
<li>
<p>Trees are a common way to represent the relationship between entities. They are often used to model UI.</p>
</li>
<li>
<p>Render trees represent the nested relationship between React components across a single render.</p>
</li>
<li>
<p>With conditional rendering, the render tree may change across different renders. With different prop values, components may render different children components.</p>
</li>
<li>
<p>Render trees help identify what the top-level and leaf components are. Top-level components affect the rendering performance of all components beneath them and leaf components are often re-rendered frequently. Identifying them is useful for understanding and debugging rendering performance.</p>
</li>
<li>
<p>Dependency trees represent the module dependencies in a React app.</p>
</li>
<li>
<p>Dependency trees are used by build tools to bundle the necessary code to ship an app.</p>
</li>
<li>
<p>Dependency trees are useful for debugging large bundle sizes that slow time to paint and expose opportunities for optimizing what code is bundled.Trees are a common way to represent the relationship between entities. They are often used to model UI.</p>
</li>
</ul>
<ul>
<li>
<p>Render trees represent the nested relationship between React components across a single render.</p>
</li>
<li>
<p>With conditional rendering, the render tree may change across different renders. With different prop values, components may render different children components.</p>
</li>
<li>
<p>Render trees help identify what the top-level and leaf components are. Top-level components affect the rendering performance of all components beneath them and leaf components are often re-rendered frequently. Identifying them is useful for understanding and debugging rendering performance.</p>
</li>
<li>
<p>Dependency trees represent the module dependencies in a React app.</p>
</li>
<li>
<p>Dependency trees are used by build tools to bundle the necessary code to ship an app.</p>
</li>
<li>
<p>Dependency trees are useful for debugging large bundle sizes that slow time to paint and expose opportunities for optimizing what code is bundled.</p>
</li>
</ul>
<h3 id="advantages-of-react"><a aria-hidden="true" class="anchor-heading icon-link" href="#advantages-of-react"></a>Advantages of React</h3>
<ul>
<li>
<p><strong>Keeping a button’s rendering logic and markup together ensures that they stay in sync with each other on every edit. Conversely, details that are unrelated, such as the button’s markup and a sidebar’s markup, are isolated from each other, making it safer to change either of them on their own.</strong> - this is one of the main advantages of React, along with... </p>
</li>
<li>
<p><strong>The main performance advantage comes from React's Virtual DOM approach: In vanilla JS: When you add a new tag, you'd typically: Get a reference to the dropdown, Create a new element, Set its properties, Append it to the DOM, This triggers a complete recalculation of layout, styles, and page rendering (reflow and repaint) which is expensive, especially if your dropdown has many items. In React: When a tag is added: React updates its virtual DOM first (which is just a JavaScript object), Compares it with the previous state (diffing), Only applies the minimal necessary changes to the real DOM.</strong></p>
</li>
<li>
<p>Components allow you to build self-contained, reusable snippets of code. If you think of components as LEGO bricks, you can take these individual bricks and combine them together to form larger structures. If you need to update a piece of the UI, you can update the specific component or brick.</p>
</li>
<li>
<p>This modularity allows your code to be more maintainable as it grows because you can add, update, and delete components without touching the rest of our application.</p>
</li>
</ul>
<h3 id="working-with-jsx"><a aria-hidden="true" class="anchor-heading icon-link" href="#working-with-jsx"></a>Working with JSX</h3>
<ul>
<li>
<p>To return multiple elements from a component, wrap them with a single parent tag.</p>
</li>
<li>
<p>For example, you can use a <code>&#x3C;div></code>:</p>
</li>
<li>
<p>If you don’t want to add an extra <code>&#x3C;div></code> to your markup, you can write &#x3C;> and &#x3C;/> instead:</p>
</li>
<li>
<p>This empty tag is called a <strong>Fragment</strong>. Fragments let you group things without leaving any trace in the browser HTML tree.</p>
</li>
<li>
<p>JSX looks like HTML, but under the hood it is transformed into plain <em>JavaScript objects</em>. You can’t return two objects from a function without wrapping them into an array. This explains why you also can’t return two JSX tags without wrapping them into another tag or a Fragment.</p>
</li>
<li>
<p>But browsers don't understand JSX out of the box, so you'll need a JavaScript compiler, such as a Babel, to transform your JSX code into regular JavaScript.</p>
</li>
</ul>
<h3 id="passing-data-with-props"><a aria-hidden="true" class="anchor-heading icon-link" href="#passing-data-with-props"></a>Passing data with props</h3>
<ul>
<li>
<p>Regular HTML elements have attributes that you can use to pass pieces of information that change the behavior of those elements. For example, changing the src attribute of an <code>&#x3C;img></code> element changes the image that is shown. Changing the href attribute of an <code>&#x3C;a></code> tag changes the destination of the link.</p>
</li>
<li>
<p>In the same way, you can pass pieces of information as properties to React components. These are called props. Take for instance, the possible variations of a button:</p>
</li>
<li>
<p>Note: In React, data flows down the component tree. This is referred to as one-way data flow. State, which will be discussed in the next chapter, can be passed from parent to child components as props.</p>
</li>
<li>
<p>You can think of curly braces as a way to enter "JavaScript land" while you are in "JSX land". You can add any JavaScript expression (something that evaluates to a single value) inside curly braces.</p>
</li>
</ul>
<h3 id="managing-state-with-hooks"><a aria-hidden="true" class="anchor-heading icon-link" href="#managing-state-with-hooks"></a>Managing state with hooks</h3>
<ul>
<li>
<p>React has a set of functions called hooks. Hooks allow you to add additional logic such as state to your components. You can think of state as any information in your UI that changes over time, usually triggered by user interaction.</p>
</li>
<li>
<p>Sharing state between components </p>
</li>
<li>
<p>Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code.</p>
</li>
<li>
<p>You can use Context and Reducer to share state between Parent and deep child components.</p>
</li>
</ul>
<h3 id="responding-to-events"><a aria-hidden="true" class="anchor-heading icon-link" href="#responding-to-events"></a>Responding to events</h3>
<ul>
<li>
<p>You can handle events by passing a function as a prop to an element like <code>&#x3C;button></code>.</p>
</li>
<li>
<p>Event handlers must be passed, not called! onClick={handleClick}, not onClick={handleClick()}.</p>
</li>
<li>
<p>You can define an event handler function separately or inline.</p>
</li>
<li>
<p>Event handlers are defined inside a component, so they can access props.</p>
</li>
<li>
<p>You can declare an event handler in a parent and pass it as a prop to a child.</p>
</li>
<li>
<p>You can define your own event handler props with application-specific names.</p>
</li>
<li>
<p>Events propagate upwards. Call e.stopPropagation() on the first argument to prevent that.</p>
</li>
<li>
<p>Events may have unwanted default browser behavior. Call <code>e.preventDefault()</code> to prevent that.</p>
</li>
<li>
<p>Explicitly calling an event handler prop from a child handler is a good alternative to propagation.</p>
</li>
</ul>
<h3 id="server-and-client-components"><a aria-hidden="true" class="anchor-heading icon-link" href="#server-and-client-components"></a>Server and Client Components</h3>
<ul>
<li>
<p>The Network Boundary is a conceptual line that separates the different environments.</p>
</li>
<li>
<p>In React, you choose where to place the network boundary in your component tree. For example, you can fetch data and render a user's posts on the server (using Server Components), then render the interactive LikeButton for each post on the client (using Client Components).</p>
</li>
<li>
<p>Similarly, you can create a Nav component that is rendered on the server and shared across pages, but if you want to show an active state for links, you can render the list of Links on the client.</p>
</li>
</ul>
<h3 id="optimizing-fonts-and-images"><a aria-hidden="true" class="anchor-heading icon-link" href="#optimizing-fonts-and-images"></a>Optimizing fonts and images</h3>
<ul>
<li>
<p>Fonts play a significant role in the design of a website, but using custom fonts in your project can affect performance if the font files need to be fetched and loaded.</p>
</li>
<li>
<p><strong>Cumulative Layout Shift(CLS)</strong> is a metric used by Google to evaluate the performance and user experience of a website. With fonts, layout shift happens when the browser initially renders text in a fallback or system font and then swaps it out for a custom font once it has loaded. This swap can cause the text size, spacing, or layout to change, shifting elements around it.</p>
</li>
<li>
<p>Next.js automatically optimizes fonts in the application when you use the next/font module. It downloads font files at build time and hosts them with your other static assets. This means when a user visits your application, there are no additional network requests for fonts which would impact performance.</p>
</li>
<li>
<p>However, this means you have to manually:</p>
<ul>
<li>Ensure your image is responsive on different screen sizes.</li>
<li>Specify image sizes for different devices.</li>
<li>Prevent layout shift as the images load.</li>
<li>Lazy load images that are outside the user's viewport.</li>
<li>Image Optimization is a large topic in web development that could be considered a specialization in itself. Instead of manually implementing these optimizations, you can use the next/image component to automatically optimize your images.</li>
</ul>
</li>
<li>
<p>By adding Inter to the <code>&#x3C;body></code> element, the font will be applied throughout your application. Here, you're also adding the Tailwind antialiased class <em>which smooths out the font. It's not necessary to use this class, but it adds a nice touch.</em>
Next.js can serve static assets, like images, under the top-level /public folder. Files inside /public can be referenced in your application.</p>
</li>
</ul>
<h3 id="using-layouts"><a aria-hidden="true" class="anchor-heading icon-link" href="#using-layouts"></a>Using Layouts</h3>
<ul>
<li>
<p>Dashboards have some sort of navigation that is shared across multiple pages. In Next.js, you can use a special layout.tsx file to create UI that is shared between multiple pages. Let's create a layout for the dashboard pages!</p>
</li>
<li>
<p>First, you're importing the <code>&#x3C;SideNav /></code> component into your layout. Any components you import into this file will be part of the layout.</p>
</li>
<li>
<p>The <code>&#x3C;Layout /></code> component receives a children prop. This child can either be a page or another layout.</p>
</li>
<li>
<p>One benefit of using layouts in Next.js is that on navigation, only the page components update while the layout won't re-render. This is called partial rendering which preserves client-side React state in the layout when transitioning between pages.</p>
</li>
<li>
<p>This is called a root layout and is required in every Next.js application. Any UI you add to the root layout will be shared across all pages in your application. You can use the root layout to modify your <code>&#x3C;html></code> and <code>&#x3C;body></code> tags, and add metadata (you'll learn more about metadata in a later chapter).</p>
</li>
</ul>
<h3 id="routing-and-code-splitting"><a aria-hidden="true" class="anchor-heading icon-link" href="#routing-and-code-splitting"></a>Routing and code-splitting</h3>
<ul>
<li>
<p>Code splitting allows you to split your application code into smaller bundles to be downloaded and executed by the browser. This reduces the amount of data transferred and execution time for each request, leading to improved performance.</p>
</li>
<li>
<p>Server Components allow your application code to be automatically code-split by route segments. This means only the code needed for the current route is loaded on navigation.</p>
</li>
</ul>
<ul>
<li>The App Router uses a hybrid approach for routing and navigation. On the server, your application code is automatically code-split by route segments. And on the client, Next.js prefetches and caches the route segments. This means, when a user navigates to a new route, the browser doesn't reload the page, and only the route segments that change re-render - improving the navigation experience and performance.</li>
</ul>
<ul>
<li>
<p>To improve the navigation experience, Next.js automatically code splits your application by route segments. This is different from a traditional React SPA, where the browser loads all your application code on the initial page load.</p>
</li>
<li>
<p>Splitting code by routes means that pages become isolated. If a certain page throws an error, the rest of the application will still work. This is also less code for the browser to parse, which makes your application faster.</p>
</li>
<li>
<p>Furthermore, in production, whenever <code>&#x3C;Link></code> components appear in the browser's viewport, Next.js automatically prefetches the code for the linked route in the background. By the time the user clicks the link, the code for the destination page will already be loaded in the background, and this is what makes the page transition near-instant!</p>
</li>
</ul>
<h3 id="fetching-data"><a aria-hidden="true" class="anchor-heading icon-link" href="#fetching-data"></a>Fetching Data</h3>
<p>API layer</p>
<ul>
<li>
<p>APIs are an intermediary layer between your application code and database. There are a few cases where you might use an API:</p>
<ul>
<li>If you're using third-party services that provide an API.</li>
<li>If you're fetching data from the client, you want to have an API layer that runs on the server to avoid exposing your database secrets to the client.</li>
</ul>
</li>
<li>
<p>In Next.js, you can create API endpoints using Route Handlers.</p>
</li>
<li>
<p>Database queries</p>
<ul>
<li>When you're creating a full-stack application, you'll also need to write logic to interact with your database. For relational databases like Postgres, you can do this with SQL or with an ORM.</li>
</ul>
</li>
<li>
<p>There are a few cases where you have to write database queries:</p>
<ul>
<li>When creating your API endpoints, you need to write logic to interact with your database.</li>
<li>If you are using React Server Components (fetching data on the server), you can skip the API layer, and query your database directly without risking exposing your database secrets to the client.</li>
</ul>
</li>
<li>
<p>Using Server Components to fetch data. By default, Next.js applications use React Server Components. Fetching data with Server Components is a relatively new approach and there are a few benefits of using them:</p>
</li>
<li>
<p>Server Components support JavaScript Promises, providing a solution for asynchronous tasks like data fetching natively. You can use async/await syntax without needing useEffect, useState or other data fetching libraries.</p>
</li>
<li>
<p>Server Components run on the server, so you can keep expensive data fetches and logic on the server, only sending the result to the client.</p>
</li>
<li>
<p>Since Server Components run on the server, you can query the database directly without an additional API layer. This saves you from writing and maintaining additional code.</p>
</li>
</ul>
<h3 id="project-structure-for-a-next-js-app"><a aria-hidden="true" class="anchor-heading icon-link" href="#project-structure-for-a-next-js-app"></a>Project structure for a Next JS app</h3>
<ul>
<li>
<p><code>/app</code>: Contains all the routes, components, and logic for your application, this is where you'll be mostly working from.</p>
</li>
<li>
<p><code>/app/lib</code>: Contains functions used in your application, such as reusable utility functions and data fetching functions.</p>
</li>
<li>
<p><code>/app/ui</code>: Contains all the UI components for your application, such as cards, tables, and forms. To save time, we've pre-styled these components for you.</p>
</li>
<li>
<p><code>/public</code>: Contains all the static assets for your application, such as images.</p>
</li>
<li>
<p>Config Files: You'll also notice config files such as next.config.ts at the root of your application. Most of these files are created and pre-configured when you start a new project using create-next-app. You will not need to modify them in this course.</p>
</li>
</ul>
<h3 id="working-with-images-in-next-js"><a aria-hidden="true" class="anchor-heading icon-link" href="#working-with-images-in-next-js"></a>Working with images in Next JS</h3>
<ul>
<li>
<p>Next.js can serve static assets, like images, under the top-level /public folder. Files inside /public can be referenced in your application.</p>
</li>
<li>
<p>With regular HTML, you would add an image as follows:</p>
<pre><code>&#x3C;img
src="/hero.png"
alt="Screenshots of the dashboard project showing desktop version"
/>
</code></pre>
</li>
<li>
<p>However, this means you have to manually:</p>
<ul>
<li>Ensure your image is responsive on different screen sizes.</li>
<li>Specify image sizes for different devices.</li>
<li>Prevent layout shift as the images load.</li>
<li>Lazy load images that are outside the user's viewport.</li>
<li>Image Optimization is a large topic in web development that could be considered a specialization in itself. Instead of manually implementing these optimizations, you can use the next/image component to automatically optimize your images.</li>
</ul>
</li>
<li>
<p>The <code>&#x3C;Image></code> Component is an extension of the HTML <code>&#x3C;img></code> tag, and comes with automatic image optimization, such as:</p>
<ul>
<li>Preventing layout shift automatically when images are loading.</li>
<li>Resizing images to avoid shipping large images to devices with a smaller viewport.</li>
<li>Lazy loading images by default (images load as they enter the viewport).</li>
<li>Serving images in modern formats, like WebP and AVIF, when the browser supports it.</li>
</ul>
</li>
<li>
<p>It's good practice to set the width and height of your images to avoid layout shift, these should be an aspect ratio <em>identical</em> to the source image. These values are not the size the image is rendered, but instead the size of the actual image file used to understand the aspect ratio.</p>
</li>
</ul>
<h3 id="static-rendering-vs-dynamic-rendering"><a aria-hidden="true" class="anchor-heading icon-link" href="#static-rendering-vs-dynamic-rendering"></a>Static Rendering vs Dynamic Rendering</h3>
<ul>
<li>
<p>With <strong>static rendering</strong>, data fetching and rendering happens on the server at build time (when you deploy) or when revalidating data. Whenever a user visits your application, the cached result is served.</p>
</li>
<li>
<p>There are a couple of benefits of static rendering:</p>
<ul>
<li>Faster Websites - Prerendered content can be cached and globally distributed when deployed to platforms like Vercel. This ensures that users around the world can access your website's content more quickly and reliably.</li>
<li>Reduced Server Load - Because the content is cached, your server does not have to dynamically generate content for each user request. This can reduce compute costs.</li>
<li>SEO - Prerendered content is easier for search engine crawlers to index, as the content is already available when the page loads. This can lead to improved search engine rankings.</li>
<li>Static rendering is useful for UI with no data or data that is shared across users, such as a static blog post or a product page. It might not be a good fit for a dashboard that has personalized data which is regularly updated.</li>
</ul>
</li>
<li>
<p>With <strong>dynamic rendering</strong>, content is rendered on the server for each user at request time (when the user visits the page). There are a couple of benefits of dynamic rendering:</p>
<ul>
<li>Real-Time Data - Dynamic rendering allows your application to display real-time or frequently updated data. This is ideal for applications where data changes often.</li>
<li>User-Specific Content - It's easier to serve personalized content, such as dashboards or user profiles, and update the data based on user interaction.</li>
<li>Request Time Information - Dynamic rendering allows you to access information that can only be known at request time, such as cookies or the URL search parameters.</li>
</ul>
</li>
</ul>
<h3 id="streaming-and-suspense"><a aria-hidden="true" class="anchor-heading icon-link" href="#streaming-and-suspense"></a>Streaming and Suspense</h3>
<ul>
<li>Deciding where to place your Suspense boundaries:
<ul>
<li>You could stream the whole page like we did with loading.tsx... but that may lead to a longer loading time if one of the components has a slow data fetch.</li>
<li>You could stream every component individually... but that may lead to UI popping into the screen as it becomes ready.</li>
<li>You could also create a staggered effect by streaming page sections. But you'll need to create wrapper components.</li>
<li>Where you place your suspense boundaries will vary depending on your application. In general, it's good practice to move your data fetches down to the components that need it, and then wrap those components in Suspense. But there is nothing wrong with streaming the sections or the whole page if that's what your application needs.</li>
</ul>
</li>
</ul>
<h3 id="search-and-pagination"><a aria-hidden="true" class="anchor-heading icon-link" href="#search-and-pagination"></a>Search and Pagination</h3>
<ul>
<li>
<p>As mentioned above, you'll be using URL search params to manage the search state. This pattern may be new if you're used to doing it with client side state.</p>
</li>
<li>
<p>There are a couple of benefits of implementing search with URL params:</p>
<ul>
<li><strong>Bookmarkable and shareable URLs</strong>: Since the search parameters are in the URL, users can bookmark the current state of the application, including their search queries and filters, for future reference or sharing.</li>
<li><strong>Server-side rendering</strong>: URL parameters can be directly consumed on the server to render the initial state, making it easier to handle server rendering.</li>
<li><strong>Analytics and tracking</strong>: Having search queries and filters directly in the URL makes it easier to track user behavior without requiring additional client-side logic.</li>
</ul>
</li>
<li>
<p>When to use the useSearchParams() hook vs. the searchParams prop?</p>
<ul>
<li>You might have noticed you used two different ways to extract search params. Whether you use one or the other depends on whether you're working on the client or the server.</li>
<li><code>Search</code> is a Client Component, so you used the useSearchParams() hook to access the params from the client.</li>
<li><code>Table</code> is a Server Component that fetches its own data, so you can pass the searchParams prop from the page to the component.</li>
<li>As a general rule, if you want to read the params from the client, use the useSearchParams() hook as this avoids having to go back to the server.</li>
</ul>
</li>
<li>
<p>Revalidate and redirect</p>
<ul>
<li>
<p>Next.js has a client-side router cache that stores the route segments in the user's browser for a time. Along with prefetching, this cache ensures that users can quickly navigate between routes while reducing the number of requests made to the server.</p>
</li>
<li>
<p>Since you're updating the data displayed in the invoices route, you want to clear this cache and trigger a new request to the server. You can do this with the revalidatePath function from Next.js.</p>
</li>
</ul>
</li>
</ul>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/dendron-main/notes/lgx7yt4m652gdnjzysqljk5">Goals</a></li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#intro" title="Intro">Intro</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#trees-in-react" title="Trees in React">Trees in React</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#advantages-of-react" title="Advantages of React">Advantages of React</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#working-with-jsx" title="Working with JSX">Working with JSX</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#passing-data-with-props" title="Passing data with props">Passing data with props</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#managing-state-with-hooks" title="Managing state with hooks">Managing state with hooks</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#responding-to-events" title="Responding to events">Responding to events</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#server-and-client-components" title="Server and Client Components">Server and Client Components</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#optimizing-fonts-and-images" title="Optimizing fonts and images">Optimizing fonts and images</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#using-layouts" title="Using Layouts">Using Layouts</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#routing-and-code-splitting" title="Routing and code-splitting">Routing and code-splitting</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#fetching-data" title="Fetching Data">Fetching Data</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#project-structure-for-a-next-js-app" title="Project structure for a Next JS app">Project structure for a Next JS app</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#working-with-images-in-next-js" title="Working with images in Next JS">Working with images in Next JS</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#static-rendering-vs-dynamic-rendering" title="Static Rendering vs Dynamic Rendering">Static Rendering vs Dynamic Rendering</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#streaming-and-suspense" title="Streaming and Suspense">Streaming and Suspense</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#search-and-pagination" title="Search and Pagination">Search and Pagination</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"rikfe3qd9gvj5o6a6l92cx8","title":"Tutorial","desc":"","updated":1744318952892,"created":1742910002085,"custom":{},"fname":"Next JS.Tutorial","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Dendron"},"contentHash":"b3486a58313ea09e9e596f782438c122","links":[{"from":{"fname":"Siddharth.Goals","vaultName":"Dendron"},"type":"backlink","position":{"start":{"line":53,"column":7,"offset":997},"end":{"line":53,"column":27,"offset":1017},"indent":[]},"value":"Next JS.Tutorial","alias":"Next JS.Tutorial"}],"anchors":{"intro":{"type":"header","text":"Intro","value":"intro","line":9,"column":0,"depth":3},"trees-in-react":{"type":"header","text":"Trees in React","value":"trees-in-react","line":21,"column":0,"depth":3},"advantages-of-react":{"type":"header","text":"Advantages of React","value":"advantages-of-react","line":50,"column":0,"depth":3},"working-with-jsx":{"type":"header","text":"Working with JSX","value":"working-with-jsx","line":60,"column":0,"depth":3},"passing-data-with-props":{"type":"header","text":"Passing data with props","value":"passing-data-with-props","line":74,"column":0,"depth":3},"managing-state-with-hooks":{"type":"header","text":"Managing state with hooks","value":"managing-state-with-hooks","line":84,"column":0,"depth":3},"responding-to-events":{"type":"header","text":"Responding to events","value":"responding-to-events","line":95,"column":0,"depth":3},"server-and-client-components":{"type":"header","text":"Server and Client Components","value":"server-and-client-components","line":115,"column":0,"depth":3},"optimizing-fonts-and-images":{"type":"header","text":"Optimizing fonts and images","value":"optimizing-fonts-and-images","line":123,"column":0,"depth":3},"using-layouts":{"type":"header","text":"Using Layouts","value":"using-layouts","line":141,"column":0,"depth":3},"routing-and-code-splitting":{"type":"header","text":"Routing and code-splitting","value":"routing-and-code-splitting","line":153,"column":0,"depth":3},"fetching-data":{"type":"header","text":"Fetching Data","value":"fetching-data","line":170,"column":0,"depth":3},"project-structure-for-a-next-js-app":{"type":"header","text":"Project structure for a Next JS app","value":"project-structure-for-a-next-js-app","line":194,"column":0,"depth":3},"working-with-images-in-next-js":{"type":"header","text":"Working with images in Next JS","value":"working-with-images-in-next-js","line":206,"column":0,"depth":3},"static-rendering-vs-dynamic-rendering":{"type":"header","text":"Static Rendering vs Dynamic Rendering","value":"static-rendering-vs-dynamic-rendering","line":233,"column":0,"depth":3},"streaming-and-suspense":{"type":"header","text":"Streaming and Suspense","value":"streaming-and-suspense","line":249,"column":0,"depth":3},"search-and-pagination":{"type":"header","text":"Search and Pagination","value":"search-and-pagination","line":257,"column":0,"depth":3}},"children":[],"parent":"69h59jt3vyfdg55g7gqc95d","data":{}},"body":"\u003ch1 id=\"tutorial\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#tutorial\"\u003e\u003c/a\u003eTutorial\u003c/h1\u003e\n\u003ch3 id=\"intro\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#intro\"\u003e\u003c/a\u003eIntro\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe DOM is an object representation of the HTML elements. It acts as a bridge between your code and the user interface, and has a tree-like structure with parent and child relationships.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eYou can use DOM methods and JavaScript, to listen to user events and manipulate the DOM by selecting, adding, updating, and deleting specific elements in the user interface. DOM manipulation allows you to not only target specific elements, but also change their style and content.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUpdating the DOM with plain JavaScript is very powerful but verbose. You've written all this code to add an \u003ccode\u003e\u0026#x3C;h1\u003e\u003c/code\u003e element with some text:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAs the size of an app or team grows, it can become increasingly challenging to build applications this way - writing code that manuipulates the DOM to perform business logic.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWith this approach, developers spend a lot of time writing instructions to tell the computer how it should do things. But wouldn't it be nice to describe what you want to show and let the computer figure out how to update the DOM?\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"trees-in-react\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#trees-in-react\"\u003e\u003c/a\u003eTrees in React\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTrees are a common way to represent the relationship between entities. They are often used to model UI.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRender trees represent the nested relationship between React components across a single render.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWith conditional rendering, the render tree may change across different renders. With different prop values, components may render different children components.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRender trees help identify what the top-level and leaf components are. Top-level components affect the rendering performance of all components beneath them and leaf components are often re-rendered frequently. Identifying them is useful for understanding and debugging rendering performance.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDependency trees represent the module dependencies in a React app.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDependency trees are used by build tools to bundle the necessary code to ship an app.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDependency trees are useful for debugging large bundle sizes that slow time to paint and expose opportunities for optimizing what code is bundled.Trees are a common way to represent the relationship between entities. They are often used to model UI.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eRender trees represent the nested relationship between React components across a single render.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWith conditional rendering, the render tree may change across different renders. With different prop values, components may render different children components.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRender trees help identify what the top-level and leaf components are. Top-level components affect the rendering performance of all components beneath them and leaf components are often re-rendered frequently. Identifying them is useful for understanding and debugging rendering performance.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDependency trees represent the module dependencies in a React app.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDependency trees are used by build tools to bundle the necessary code to ship an app.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDependency trees are useful for debugging large bundle sizes that slow time to paint and expose opportunities for optimizing what code is bundled.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"advantages-of-react\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#advantages-of-react\"\u003e\u003c/a\u003eAdvantages of React\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eKeeping a button’s rendering logic and markup together ensures that they stay in sync with each other on every edit. Conversely, details that are unrelated, such as the button’s markup and a sidebar’s markup, are isolated from each other, making it safer to change either of them on their own.\u003c/strong\u003e - this is one of the main advantages of React, along with... \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eThe main performance advantage comes from React's Virtual DOM approach: In vanilla JS: When you add a new tag, you'd typically: Get a reference to the dropdown, Create a new element, Set its properties, Append it to the DOM, This triggers a complete recalculation of layout, styles, and page rendering (reflow and repaint) which is expensive, especially if your dropdown has many items. In React: When a tag is added: React updates its virtual DOM first (which is just a JavaScript object), Compares it with the previous state (diffing), Only applies the minimal necessary changes to the real DOM.\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eComponents allow you to build self-contained, reusable snippets of code. If you think of components as LEGO bricks, you can take these individual bricks and combine them together to form larger structures. If you need to update a piece of the UI, you can update the specific component or brick.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThis modularity allows your code to be more maintainable as it grows because you can add, update, and delete components without touching the rest of our application.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"working-with-jsx\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#working-with-jsx\"\u003e\u003c/a\u003eWorking with JSX\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTo return multiple elements from a component, wrap them with a single parent tag.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFor example, you can use a \u003ccode\u003e\u0026#x3C;div\u003e\u003c/code\u003e:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf you don’t want to add an extra \u003ccode\u003e\u0026#x3C;div\u003e\u003c/code\u003e to your markup, you can write \u0026#x3C;\u003e and \u0026#x3C;/\u003e instead:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThis empty tag is called a \u003cstrong\u003eFragment\u003c/strong\u003e. Fragments let you group things without leaving any trace in the browser HTML tree.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eJSX looks like HTML, but under the hood it is transformed into plain \u003cem\u003eJavaScript objects\u003c/em\u003e. You can’t return two objects from a function without wrapping them into an array. This explains why you also can’t return two JSX tags without wrapping them into another tag or a Fragment.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBut browsers don't understand JSX out of the box, so you'll need a JavaScript compiler, such as a Babel, to transform your JSX code into regular JavaScript.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"passing-data-with-props\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#passing-data-with-props\"\u003e\u003c/a\u003ePassing data with props\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eRegular HTML elements have attributes that you can use to pass pieces of information that change the behavior of those elements. For example, changing the src attribute of an \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e element changes the image that is shown. Changing the href attribute of an \u003ccode\u003e\u0026#x3C;a\u003e\u003c/code\u003e tag changes the destination of the link.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIn the same way, you can pass pieces of information as properties to React components. These are called props. Take for instance, the possible variations of a button:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNote: In React, data flows down the component tree. This is referred to as one-way data flow. State, which will be discussed in the next chapter, can be passed from parent to child components as props.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eYou can think of curly braces as a way to enter \"JavaScript land\" while you are in \"JSX land\". You can add any JavaScript expression (something that evaluates to a single value) inside curly braces.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"managing-state-with-hooks\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#managing-state-with-hooks\"\u003e\u003c/a\u003eManaging state with hooks\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eReact has a set of functions called hooks. Hooks allow you to add additional logic such as state to your components. You can think of state as any information in your UI that changes over time, usually triggered by user interaction.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSharing state between components \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eYou can use Context and Reducer to share state between Parent and deep child components.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"responding-to-events\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#responding-to-events\"\u003e\u003c/a\u003eResponding to events\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eYou can handle events by passing a function as a prop to an element like \u003ccode\u003e\u0026#x3C;button\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eEvent handlers must be passed, not called! onClick={handleClick}, not onClick={handleClick()}.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eYou can define an event handler function separately or inline.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eEvent handlers are defined inside a component, so they can access props.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eYou can declare an event handler in a parent and pass it as a prop to a child.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eYou can define your own event handler props with application-specific names.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eEvents propagate upwards. Call e.stopPropagation() on the first argument to prevent that.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eEvents may have unwanted default browser behavior. Call \u003ccode\u003ee.preventDefault()\u003c/code\u003e to prevent that.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eExplicitly calling an event handler prop from a child handler is a good alternative to propagation.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"server-and-client-components\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#server-and-client-components\"\u003e\u003c/a\u003eServer and Client Components\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe Network Boundary is a conceptual line that separates the different environments.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIn React, you choose where to place the network boundary in your component tree. For example, you can fetch data and render a user's posts on the server (using Server Components), then render the interactive LikeButton for each post on the client (using Client Components).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSimilarly, you can create a Nav component that is rendered on the server and shared across pages, but if you want to show an active state for links, you can render the list of Links on the client.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"optimizing-fonts-and-images\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#optimizing-fonts-and-images\"\u003e\u003c/a\u003eOptimizing fonts and images\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eFonts play a significant role in the design of a website, but using custom fonts in your project can affect performance if the font files need to be fetched and loaded.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCumulative Layout Shift(CLS)\u003c/strong\u003e is a metric used by Google to evaluate the performance and user experience of a website. With fonts, layout shift happens when the browser initially renders text in a fallback or system font and then swaps it out for a custom font once it has loaded. This swap can cause the text size, spacing, or layout to change, shifting elements around it.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNext.js automatically optimizes fonts in the application when you use the next/font module. It downloads font files at build time and hosts them with your other static assets. This means when a user visits your application, there are no additional network requests for fonts which would impact performance.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHowever, this means you have to manually:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEnsure your image is responsive on different screen sizes.\u003c/li\u003e\n\u003cli\u003eSpecify image sizes for different devices.\u003c/li\u003e\n\u003cli\u003ePrevent layout shift as the images load.\u003c/li\u003e\n\u003cli\u003eLazy load images that are outside the user's viewport.\u003c/li\u003e\n\u003cli\u003eImage Optimization is a large topic in web development that could be considered a specialization in itself. Instead of manually implementing these optimizations, you can use the next/image component to automatically optimize your images.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBy adding Inter to the \u003ccode\u003e\u0026#x3C;body\u003e\u003c/code\u003e element, the font will be applied throughout your application. Here, you're also adding the Tailwind antialiased class \u003cem\u003ewhich smooths out the font. It's not necessary to use this class, but it adds a nice touch.\u003c/em\u003e\nNext.js can serve static assets, like images, under the top-level /public folder. Files inside /public can be referenced in your application.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"using-layouts\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#using-layouts\"\u003e\u003c/a\u003eUsing Layouts\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eDashboards have some sort of navigation that is shared across multiple pages. In Next.js, you can use a special layout.tsx file to create UI that is shared between multiple pages. Let's create a layout for the dashboard pages!\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFirst, you're importing the \u003ccode\u003e\u0026#x3C;SideNav /\u003e\u003c/code\u003e component into your layout. Any components you import into this file will be part of the layout.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003e\u0026#x3C;Layout /\u003e\u003c/code\u003e component receives a children prop. This child can either be a page or another layout.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOne benefit of using layouts in Next.js is that on navigation, only the page components update while the layout won't re-render. This is called partial rendering which preserves client-side React state in the layout when transitioning between pages.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThis is called a root layout and is required in every Next.js application. Any UI you add to the root layout will be shared across all pages in your application. You can use the root layout to modify your \u003ccode\u003e\u0026#x3C;html\u003e\u003c/code\u003e and \u003ccode\u003e\u0026#x3C;body\u003e\u003c/code\u003e tags, and add metadata (you'll learn more about metadata in a later chapter).\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"routing-and-code-splitting\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#routing-and-code-splitting\"\u003e\u003c/a\u003eRouting and code-splitting\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eCode splitting allows you to split your application code into smaller bundles to be downloaded and executed by the browser. This reduces the amount of data transferred and execution time for each request, leading to improved performance.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eServer Components allow your application code to be automatically code-split by route segments. This means only the code needed for the current route is loaded on navigation.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eThe App Router uses a hybrid approach for routing and navigation. On the server, your application code is automatically code-split by route segments. And on the client, Next.js prefetches and caches the route segments. This means, when a user navigates to a new route, the browser doesn't reload the page, and only the route segments that change re-render - improving the navigation experience and performance.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTo improve the navigation experience, Next.js automatically code splits your application by route segments. This is different from a traditional React SPA, where the browser loads all your application code on the initial page load.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSplitting code by routes means that pages become isolated. If a certain page throws an error, the rest of the application will still work. This is also less code for the browser to parse, which makes your application faster.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFurthermore, in production, whenever \u003ccode\u003e\u0026#x3C;Link\u003e\u003c/code\u003e components appear in the browser's viewport, Next.js automatically prefetches the code for the linked route in the background. By the time the user clicks the link, the code for the destination page will already be loaded in the background, and this is what makes the page transition near-instant!\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"fetching-data\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#fetching-data\"\u003e\u003c/a\u003eFetching Data\u003c/h3\u003e\n\u003cp\u003eAPI layer\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAPIs are an intermediary layer between your application code and database. There are a few cases where you might use an API:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you're using third-party services that provide an API.\u003c/li\u003e\n\u003cli\u003eIf you're fetching data from the client, you want to have an API layer that runs on the server to avoid exposing your database secrets to the client.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIn Next.js, you can create API endpoints using Route Handlers.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDatabase queries\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhen you're creating a full-stack application, you'll also need to write logic to interact with your database. For relational databases like Postgres, you can do this with SQL or with an ORM.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThere are a few cases where you have to write database queries:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhen creating your API endpoints, you need to write logic to interact with your database.\u003c/li\u003e\n\u003cli\u003eIf you are using React Server Components (fetching data on the server), you can skip the API layer, and query your database directly without risking exposing your database secrets to the client.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUsing Server Components to fetch data. By default, Next.js applications use React Server Components. Fetching data with Server Components is a relatively new approach and there are a few benefits of using them:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eServer Components support JavaScript Promises, providing a solution for asynchronous tasks like data fetching natively. You can use async/await syntax without needing useEffect, useState or other data fetching libraries.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eServer Components run on the server, so you can keep expensive data fetches and logic on the server, only sending the result to the client.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSince Server Components run on the server, you can query the database directly without an additional API layer. This saves you from writing and maintaining additional code.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"project-structure-for-a-next-js-app\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#project-structure-for-a-next-js-app\"\u003e\u003c/a\u003eProject structure for a Next JS app\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/app\u003c/code\u003e: Contains all the routes, components, and logic for your application, this is where you'll be mostly working from.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/app/lib\u003c/code\u003e: Contains functions used in your application, such as reusable utility functions and data fetching functions.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/app/ui\u003c/code\u003e: Contains all the UI components for your application, such as cards, tables, and forms. To save time, we've pre-styled these components for you.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/public\u003c/code\u003e: Contains all the static assets for your application, such as images.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eConfig Files: You'll also notice config files such as next.config.ts at the root of your application. Most of these files are created and pre-configured when you start a new project using create-next-app. You will not need to modify them in this course.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"working-with-images-in-next-js\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#working-with-images-in-next-js\"\u003e\u003c/a\u003eWorking with images in Next JS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eNext.js can serve static assets, like images, under the top-level /public folder. Files inside /public can be referenced in your application.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWith regular HTML, you would add an image as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;img\nsrc=\"/hero.png\"\nalt=\"Screenshots of the dashboard project showing desktop version\"\n/\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHowever, this means you have to manually:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEnsure your image is responsive on different screen sizes.\u003c/li\u003e\n\u003cli\u003eSpecify image sizes for different devices.\u003c/li\u003e\n\u003cli\u003ePrevent layout shift as the images load.\u003c/li\u003e\n\u003cli\u003eLazy load images that are outside the user's viewport.\u003c/li\u003e\n\u003cli\u003eImage Optimization is a large topic in web development that could be considered a specialization in itself. Instead of manually implementing these optimizations, you can use the next/image component to automatically optimize your images.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003e\u0026#x3C;Image\u003e\u003c/code\u003e Component is an extension of the HTML \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e tag, and comes with automatic image optimization, such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePreventing layout shift automatically when images are loading.\u003c/li\u003e\n\u003cli\u003eResizing images to avoid shipping large images to devices with a smaller viewport.\u003c/li\u003e\n\u003cli\u003eLazy loading images by default (images load as they enter the viewport).\u003c/li\u003e\n\u003cli\u003eServing images in modern formats, like WebP and AVIF, when the browser supports it.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIt's good practice to set the width and height of your images to avoid layout shift, these should be an aspect ratio \u003cem\u003eidentical\u003c/em\u003e to the source image. These values are not the size the image is rendered, but instead the size of the actual image file used to understand the aspect ratio.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"static-rendering-vs-dynamic-rendering\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#static-rendering-vs-dynamic-rendering\"\u003e\u003c/a\u003eStatic Rendering vs Dynamic Rendering\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eWith \u003cstrong\u003estatic rendering\u003c/strong\u003e, data fetching and rendering happens on the server at build time (when you deploy) or when revalidating data. Whenever a user visits your application, the cached result is served.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThere are a couple of benefits of static rendering:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFaster Websites - Prerendered content can be cached and globally distributed when deployed to platforms like Vercel. This ensures that users around the world can access your website's content more quickly and reliably.\u003c/li\u003e\n\u003cli\u003eReduced Server Load - Because the content is cached, your server does not have to dynamically generate content for each user request. This can reduce compute costs.\u003c/li\u003e\n\u003cli\u003eSEO - Prerendered content is easier for search engine crawlers to index, as the content is already available when the page loads. This can lead to improved search engine rankings.\u003c/li\u003e\n\u003cli\u003eStatic rendering is useful for UI with no data or data that is shared across users, such as a static blog post or a product page. It might not be a good fit for a dashboard that has personalized data which is regularly updated.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWith \u003cstrong\u003edynamic rendering\u003c/strong\u003e, content is rendered on the server for each user at request time (when the user visits the page). There are a couple of benefits of dynamic rendering:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReal-Time Data - Dynamic rendering allows your application to display real-time or frequently updated data. This is ideal for applications where data changes often.\u003c/li\u003e\n\u003cli\u003eUser-Specific Content - It's easier to serve personalized content, such as dashboards or user profiles, and update the data based on user interaction.\u003c/li\u003e\n\u003cli\u003eRequest Time Information - Dynamic rendering allows you to access information that can only be known at request time, such as cookies or the URL search parameters.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"streaming-and-suspense\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#streaming-and-suspense\"\u003e\u003c/a\u003eStreaming and Suspense\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDeciding where to place your Suspense boundaries:\n\u003cul\u003e\n\u003cli\u003eYou could stream the whole page like we did with loading.tsx... but that may lead to a longer loading time if one of the components has a slow data fetch.\u003c/li\u003e\n\u003cli\u003eYou could stream every component individually... but that may lead to UI popping into the screen as it becomes ready.\u003c/li\u003e\n\u003cli\u003eYou could also create a staggered effect by streaming page sections. But you'll need to create wrapper components.\u003c/li\u003e\n\u003cli\u003eWhere you place your suspense boundaries will vary depending on your application. In general, it's good practice to move your data fetches down to the components that need it, and then wrap those components in Suspense. But there is nothing wrong with streaming the sections or the whole page if that's what your application needs.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"search-and-pagination\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#search-and-pagination\"\u003e\u003c/a\u003eSearch and Pagination\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAs mentioned above, you'll be using URL search params to manage the search state. This pattern may be new if you're used to doing it with client side state.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThere are a couple of benefits of implementing search with URL params:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBookmarkable and shareable URLs\u003c/strong\u003e: Since the search parameters are in the URL, users can bookmark the current state of the application, including their search queries and filters, for future reference or sharing.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eServer-side rendering\u003c/strong\u003e: URL parameters can be directly consumed on the server to render the initial state, making it easier to handle server rendering.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAnalytics and tracking\u003c/strong\u003e: Having search queries and filters directly in the URL makes it easier to track user behavior without requiring additional client-side logic.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhen to use the useSearchParams() hook vs. the searchParams prop?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou might have noticed you used two different ways to extract search params. Whether you use one or the other depends on whether you're working on the client or the server.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSearch\u003c/code\u003e is a Client Component, so you used the useSearchParams() hook to access the params from the client.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTable\u003c/code\u003e is a Server Component that fetches its own data, so you can pass the searchParams prop from the page to the component.\u003c/li\u003e\n\u003cli\u003eAs a general rule, if you want to read the params from the client, use the useSearchParams() hook as this avoids having to go back to the server.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRevalidate and redirect\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eNext.js has a client-side router cache that stores the route segments in the user's browser for a time. Along with prefetching, this cache ensures that users can quickly navigate between routes while reducing the number of requests made to the server.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSince you're updating the data displayed in the invoices route, you want to clear this cache and trigger a new request to the server. You can do this with the revalidatePath function from Next.js.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cstrong\u003eBacklinks\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/dendron-main/notes/lgx7yt4m652gdnjzysqljk5\"\u003eGoals\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"root","title":"root","desc":"","updated":1746040151076,"created":1595961348801,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Dendron"},"contentHash":"3338f3f44ea53fff248fd70b6ad85170","links":[],"anchors":{},"children":["oz8e6a05bjgd3cbtru3hqe2","c1bs7wsjfbhb0zipaywqv1","3x4fmd16chquma6kovvfatj","gdjyzsq56qgyj5t5uktrsgu","69h59jt3vyfdg55g7gqc95d","wz9z8az9m9aq5132p7d10co","l1lcmphk4ubvu1aiqhcs7ib","bd3mupfj68nrgnjejss1qqh","1tlnuf6o2f3qawzg799ilzk","z5mfdumpr0cv3ceh60flq8n","filwymswyiwdojrwinvy5xd"],"parent":null,"data":{},"body":"\nSiddharth's root\n\nThis vault contains all the verticals to climb."},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"Dendron"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false,"enableHandlebarTemplates":true,"enableSmartRefs":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableMermaid":true},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://sid1081.github.io","assetsPrefix":"/dendron-main","enableMermaid":true,"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"rikfe3qd9gvj5o6a6l92cx8"},"buildId":"j1tAvk9N20cOpobDNsQ-j","assetPrefix":"/dendron-main","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>